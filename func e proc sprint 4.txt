CREATE OR REPLACE FUNCTION criaJson (p_query IN VARCHAR2) RETURN CLOB IS
  /* Declaração de variáveis auxiliares */
  v_cursor     INTEGER;
  v_colcnt     INTEGER;
  v_desc_tab   DBMS_SQL.DESC_TAB;
  v_colnum     INTEGER;
  v_status     INTEGER;
  v_varchar2   VARCHAR2(4000);
  v_num        NUMBER;
  v_clob       CLOB := EMPTY_CLOB();
  v_row_json   CLOB;
  v_first_row  BOOLEAN := TRUE;
BEGIN
  v_cursor := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(v_cursor, p_query, DBMS_SQL.NATIVE);
  DBMS_SQL.DESCRIBE_COLUMNS(v_cursor, v_colcnt, v_desc_tab);

  FOR i IN 1 .. v_colcnt LOOP
    DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_varchar2, 4000);
  END LOOP;

  v_status := DBMS_SQL.EXECUTE(v_cursor);

  DBMS_LOB.CREATETEMPORARY(v_clob, TRUE);
  DBMS_LOB.WRITEAPPEND(v_clob, LENGTH('['), '[');
  
  /* Loop para percorrer cada linha da tabela */
  LOOP
    /* Verificação da quantidade de linhas da tabela */
    IF DBMS_SQL.FETCH_ROWS(v_cursor) = 0 THEN
      EXIT;
    END IF;

    v_row_json := '{';
    FOR i IN 1 .. v_colcnt LOOP
      DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_varchar2);

      v_varchar2 := REPLACE(REPLACE(NVL(v_varchar2,''), '\', '\\'), '"', '\"');

      DECLARE
        v_tmp NUMBER;
        is_num BOOLEAN := FALSE;
      BEGIN
        BEGIN
          v_tmp := TO_NUMBER(v_varchar2);
          is_num := TRUE;
        EXCEPTION
          WHEN OTHERS THEN
            is_num := FALSE;
        END;

        IF is_num THEN
          v_row_json := v_row_json || '"' || v_desc_tab(i).col_name || '":' || v_varchar2;
        ELSE
          v_row_json := v_row_json || '"' || v_desc_tab(i).col_name || '":"' || v_varchar2 || '"';
        END IF;
      END;

      IF i < v_colcnt THEN
        v_row_json := v_row_json || ',';
      END IF;
    END LOOP;

    v_row_json := v_row_json || '}';

    IF v_first_row THEN
      v_first_row := FALSE;
      DBMS_LOB.WRITEAPPEND(v_clob, LENGTH(v_row_json), v_row_json);
    ELSE
      DBMS_LOB.WRITEAPPEND(v_clob, LENGTH(','||v_row_json), ','||v_row_json);
    END IF;
  END LOOP;

  DBMS_LOB.WRITEAPPEND(v_clob, LENGTH(']'), ']');
  DBMS_SQL.CLOSE_CURSOR(v_cursor);

  RETURN v_clob;

/* Tratamento de exceções específicas e genéricas */
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    IF DBMS_SQL.IS_OPEN(v_cursor) THEN DBMS_SQL.CLOSE_CURSOR(v_cursor); END IF;
    RETURN '[ ]';
  WHEN VALUE_ERROR THEN
    IF DBMS_SQL.IS_OPEN(v_cursor) THEN DBMS_SQL.CLOSE_CURSOR(v_cursor); END IF;
    RETURN '{"error":"value_error converting column"}';
  WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(v_cursor) THEN DBMS_SQL.CLOSE_CURSOR(v_cursor); END IF;
    RETURN '{"error":"unexpected: ' || SQLERRM || '"}';
END criaJson;
/

------------------------------------------------------------------------
-- FUNÇÃO: Função principal de validação de senha
-- Entrada: senha
-- Saída: Mensagem com status da senha escolhida
------------------------------------------------------------------------
 
CREATE OR REPLACE FUNCTION fnc_valsenha(p_senha IN VARCHAR2) RETURN VARCHAR2 IS
  /* Declaração de variáveis auxiliares */
  v_len NUMBER;
  has_digit BOOLEAN := FALSE;
  has_upper BOOLEAN := FALSE;
  e_no_digit EXCEPTION;
  e_no_upper EXCEPTION;
BEGIN
  /* Verificação inicial: senha nula */
  IF p_senha IS NULL THEN
    RETURN 'ERRO: Senha nula';
  END IF;

  v_len := LENGTH(p_senha);
  
  /* Verificação do tamanho mínimo da senha */
  IF v_len < 6 THEN
    RETURN 'ERRO: Senha muito curta (min 6)';
  END IF;

  /* Loop para percorrer cada caractere da senha */
  FOR i IN 1 .. v_len LOOP
    DECLARE
      ch CHAR(1) := SUBSTR(p_senha, i, 1);
    BEGIN
      IF ch BETWEEN '0' AND '9' THEN
        has_digit := TRUE;
      END IF;
      IF ch BETWEEN 'A' AND 'Z' THEN
        has_upper := TRUE;
      END IF;
    /* Tratamento de possíveis erros de conversão de caractere */
    EXCEPTION
      WHEN VALUE_ERROR THEN
        NULL;
    END;
  END LOOP;

  /* Validações finais: exige dígito e letra maiúscula */
  IF NOT has_digit THEN
    RAISE e_no_digit;
  END IF;
  IF NOT has_upper THEN
    RAISE e_no_upper;
  END IF;

  RETURN 'OK';

/* Tratamento de exceções específicas e genéricas */
EXCEPTION
  WHEN VALUE_ERROR THEN
    RETURN 'ERRO: Value error na validação';
  WHEN NO_DATA_FOUND THEN
    RETURN 'ERRO: Dado não encontrado (improvável aqui)';
  WHEN e_no_digit THEN
    RETURN 'ERRO: Deve conter ao menos um dígito';
  WHEN e_no_upper THEN
    RETURN 'ERRO: Deve conter ao menos uma letra maiúscula';
    WHEN OTHERS THEN
    RETURN 'ERRO INESPERADO: ' || SQLERRM;
END fnc_valsenha;
/

/* ============================================================
   Procedure: proc_json
   Objetivo : Utiliza a função criaJson para 3 tabelas unidas
   Parâmetros:
      - v_sql : a query que vai ser mandada para a função
      - v_json   : o resultado da função
   ============================================================ */

CREATE OR REPLACE PROCEDURE proc_json IS
  /* Inicialização de variáveis locais e objetos auxiliares */
  v_sql   VARCHAR2(4000);
  v_json  CLOB;
BEGIN
  /* Execução da lógica principal da procedure */
  v_sql := 'SELECT m.idmoto, m.placamoto, m.modelomoto, m.quilometragemmoto, c.id_contrato, c.valortotalcontrato, p.idpatio, p.nomepatio ' ||
           'FROM mt_moto m ' ||
           'JOIN mt_contrato c ON m.mt_contrato_id_contrato = c.id_contrato ' ||
           'JOIN mt_patio p ON m.mt_patio_idpatio = p.idpatio ' ||
           'ORDER BY p.idpatio, c.id_contrato, m.idmoto';

  v_json := criaJson(v_sql);

  DBMS_OUTPUT.PUT_LINE('JSON DAS TABELAS');
  DBMS_OUTPUT.PUT_LINE(v_json);

/* Tratamento de exceções e erros esperados */
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Proc1: Nenhum dado encontrado para o JOIN.');
  WHEN VALUE_ERROR THEN
    DBMS_OUTPUT.PUT_LINE('Proc1: Erro de conversão de valor (VALUE_ERROR).');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Proc1: Erro inesperado: ' || SQLERRM);
END proc_json;
/

/* ============================================================
   Procedure: proc_motos_p_patio
   Objetivo : imprime linhas por combinação e faz somas manualmente (loops) sem usar ROLLUP/CUBE/GROUPING SETS
   Parâmetros:
      - v_total : representa o total de quilometragem por agencia/conta
   ============================================================ */

CREATE OR REPLACE PROCEDURE proc_motos_p_patio IS
  CURSOR cur_agencias IS
    SELECT DISTINCT
    "A1"."MT_PATIO_IDPATIO" "IDPATIO"
FROM
    "RM558199"."MT_MOTO" "A1"
ORDER BY
    "A1"."MT_PATIO_IDPATIO";

  CURSOR cur_contas(p_idpatio NUMBER) IS
    SELECT DISTINCT mt_contrato_id_contrato AS idcon
    FROM mt_moto
    WHERE mt_patio_idpatio = p_idpatio
    ORDER BY mt_contrato_id_contrato;

  v_idpatio    mt_moto.mt_patio_idpatio%TYPE;
  v_idcon      mt_moto.mt_contrato_id_contrato%TYPE;
  v_sum_line   NUMBER := 0;
  v_subtotal   NUMBER := 0;
  v_total      NUMBER := 0;

  v_val        NUMBER;
BEGIN
  DBMS_OUTPUT.PUT_LINE('AGENCIA | CONTA | SOMA(quilometragem)');
  DBMS_OUTPUT.PUT_LINE('---------------------------------');

  OPEN cur_agencias;
  LOOP
    FETCH cur_agencias INTO v_idpatio;
    EXIT WHEN cur_agencias%NOTFOUND;

    v_subtotal := 0;

    FOR rec_con IN cur_contas(v_idpatio) LOOP
      v_idcon := rec_con.idcon;
      v_sum_line := 0;

      FOR r IN (SELECT quilometragemmoto val FROM mt_moto
                WHERE mt_patio_idpatio = v_idpatio
                  AND mt_contrato_id_contrato = v_idcon) LOOP
        BEGIN
          v_val := NVL(r.val, 0);
          v_sum_line := v_sum_line + v_val;
        EXCEPTION
          WHEN VALUE_ERROR THEN
            DBMS_OUTPUT.PUT_LINE('Valor inválido para quilometragem em agencia '||v_idpatio||' conta '||v_idcon);
        END;
      END LOOP;

      DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(v_idpatio),'NULL') || ' | ' || NVL(TO_CHAR(v_idcon),'NULL') || ' | ' || TO_CHAR(v_sum_line));
      v_subtotal := v_subtotal + v_sum_line;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE(TO_CHAR(v_idpatio) || ' | ' || 'NULL' || ' | ' || TO_CHAR(v_subtotal));
    v_total := v_total + v_subtotal;
  END LOOP;
  CLOSE cur_agencias;

  DBMS_OUTPUT.PUT_LINE('NULL | NULL | ' || TO_CHAR(v_total));

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Proc2: Nenhum dado encontrado na tabela fato.');
  WHEN VALUE_ERROR THEN
    DBMS_OUTPUT.PUT_LINE('Proc2: Erro de conversão numérica durante os somatórios.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Proc2: Erro inesperado: ' || SQLERRM);
END proc_motos_p_patio;
/

/* ============================================================
   Trigger : trg_audit_mt_moto
   Evento  : BEFORE/AFTER INSERT/UPDATE/DELETE ON <TABELA>
   Objetivo: Registra alterações na tabela MT_MOTO
   ============================================================ */

CREATE OR REPLACE TRIGGER trg_audit_mt_moto
/* Verificação de condições antes da execução da ação */
AFTER INSERT OR UPDATE OR DELETE ON mt_moto
FOR EACH ROW
DECLARE
  v_user VARCHAR2(100) := NVL(USER, 'UNKNOWN');
  v_old  CLOB := NULL;
  v_new  CLOB := NULL;
  v_err  VARCHAR2(4000);
/* Execução da lógica principal da trigger */
  PROCEDURE row_to_clob(p_prefix VARCHAR2, p_idmoto NUMBER, p_placa VARCHAR2, p_modelo VARCHAR2, p_qt NUMBER, p_est VARCHAR2) IS
  BEGIN
    IF p_prefix = 'OLD' THEN
      v_old := '{ "idmoto":' || NVL(TO_CHAR(p_idmoto),'null') || ', "placa":"' || NVL(p_placa,'') || '", "modelo":"' || NVL(p_modelo,'') || '", "quilometragem":' || NVL(TO_CHAR(p_qt),'null') || ', "estado":"' || NVL(p_est,'') || '" }';
    ELSE
      v_new := '{ "idmoto":' || NVL(TO_CHAR(p_idmoto),'null') || ', "placa":"' || NVL(p_placa,'') || '", "modelo":"' || NVL(p_modelo,'') || '", "quilometragem":' || NVL(TO_CHAR(p_qt),'null') || ', "estado":"' || NVL(p_est,'') || '" }';
    END IF;
  END;
BEGIN
  IF INSERTING THEN
    row_to_clob('NEW', :NEW.idmoto, :NEW.placamoto, :NEW.modelomoto, :NEW.quilometragemmoto, :NEW.estadomoto);
    INSERT INTO mt_auditoria(tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES('MT_MOTO', v_user, 'INSERT', SYSDATE, NULL, v_new);
  ELSIF UPDATING THEN
    row_to_clob('OLD', :OLD.idmoto, :OLD.placamoto, :OLD.modelomoto, :OLD.quilometragemmoto, :OLD.estadomoto);
    row_to_clob('NEW', :NEW.idmoto, :NEW.placamoto, :NEW.modelomoto, :NEW.quilometragemmoto, :NEW.estadomoto);
    INSERT INTO mt_auditoria(tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES('MT_MOTO', v_user, 'UPDATE', SYSDATE, v_old, v_new);
  ELSIF DELETING THEN
    row_to_clob('OLD', :OLD.idmoto, :OLD.placamoto, :OLD.modelomoto, :OLD.quilometragemmoto, :OLD.estadomoto);
    INSERT INTO mt_auditoria(tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES('MT_MOTO', v_user, 'DELETE', SYSDATE, v_old, NULL);
  END IF;

/* Tratamento de exceções ou logs de auditoria */
EXCEPTION
  WHEN VALUE_ERROR THEN
    INSERT INTO mt_auditoria(tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES('MT_MOTO', v_user, 'AUDIT_ERROR', SYSDATE, 'VALUE_ERROR', NULL);

  WHEN OTHERS THEN
    v_err := SQLERRM;
    INSERT INTO mt_auditoria(tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES('MT_MOTO', v_user, 'AUDIT_ERROR', SYSDATE, v_err, NULL);
END;
/

CREATE OR REPLACE PACKAGE pkg_json_util AS 
    FUNCTION criaJson(p_query IN VARCHAR2) RETURN CLOB; 
END pkg_json_util; 
/

CREATE OR REPLACE PACKAGE BODY pkg_json_util AS
  FUNCTION criaJson(p_query IN VARCHAR2) RETURN CLOB IS
    v_cursor SYS_REFCURSOR;
    v_json   CLOB := '[';
    v_first  BOOLEAN := TRUE;

    v_idmoto           NUMBER;
    v_placamoto        VARCHAR2(100);
    v_modelomoto       VARCHAR2(100);
    v_quilometragemmoto NUMBER;
  BEGIN
    OPEN v_cursor FOR p_query;
    LOOP
      FETCH v_cursor INTO v_idmoto, v_placamoto, v_modelomoto, v_quilometragemmoto;
      EXIT WHEN v_cursor%NOTFOUND;

      IF NOT v_first THEN
        v_json := v_json || ',';
      END IF;

      v_json := v_json || '{"idmoto":' || v_idmoto ||
                ',"placamoto":"' || v_placamoto ||
                '","modelomoto":"' || v_modelomoto ||
                '","quilometragemmoto":' || v_quilometragemmoto || '}';

      v_first := FALSE;
    END LOOP;
    CLOSE v_cursor;

    v_json := v_json || ']';
    RETURN v_json;
  END criaJson;
END pkg_json_util;
/

CREATE OR REPLACE PACKAGE pkg_seguranca AS
  FUNCTION fnc_valsenha(p_senha IN VARCHAR2) RETURN VARCHAR2;
END pkg_seguranca;
/
CREATE OR REPLACE PACKAGE BODY pkg_seguranca AS
  FUNCTION fnc_valsenha(p_senha IN VARCHAR2) RETURN VARCHAR2 IS
    v_result VARCHAR2(200);
  BEGIN
    IF LENGTH(p_senha) < 8 THEN
      v_result := 'SENHA CURTA';
    ELSIF REGEXP_LIKE(p_senha, '^[A-Za-z0-9]+$') THEN
      v_result := 'SENHA OK';
    ELSE
      v_result := 'SENHA INV�LIDA';
    END IF;
    RETURN v_result;
  END fnc_valsenha;
END pkg_seguranca;
/

CREATE OR REPLACE PACKAGE pkg_relatorios AS
  PROCEDURE proc_json;
  PROCEDURE proc_motos_p_patio;
END pkg_relatorios;
/
CREATE OR REPLACE PACKAGE BODY pkg_relatorios AS

  PROCEDURE proc_json IS
    v_json CLOB;
  BEGIN
    v_json := pkg_json_util.criaJson('SELECT idmoto, placamoto, modelomoto, quilometragemmoto FROM mt_moto');
    DBMS_OUTPUT.PUT_LINE(v_json);
  END proc_json;

  PROCEDURE proc_motos_p_patio IS
    v_total_motos NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_total_motos FROM mt_moto;
    DBMS_OUTPUT.PUT_LINE('Total de motos: ' || v_total_motos);
  END proc_motos_p_patio;

END pkg_relatorios;
/

CREATE OR REPLACE PACKAGE pkg_auditoria AS
  PROCEDURE grava_auditoria(
    p_tabela    IN VARCHAR2,
    p_usuario   IN VARCHAR2,
    p_operacao  IN VARCHAR2,
    p_old       IN CLOB,
    p_new       IN CLOB
  );
END pkg_auditoria;
/
CREATE OR REPLACE PACKAGE BODY pkg_auditoria AS
  PROCEDURE grava_auditoria(
    p_tabela    IN VARCHAR2,
    p_usuario   IN VARCHAR2,
    p_operacao  IN VARCHAR2,
    p_old       IN CLOB,
    p_new       IN CLOB
  ) IS
  BEGIN
    INSERT INTO mt_auditoria (tabela_nome, usuario_nome, tipo_operacao, data_hora, valores_old, valores_new)
    VALUES (p_tabela, p_usuario, p_operacao, SYSDATE, p_old, p_new);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Erro ao gravar auditoria: ' || SQLERRM);
  END grava_auditoria;
END pkg_auditoria;
/

CREATE OR REPLACE TRIGGER trg_mt_moto_audit
AFTER INSERT OR UPDATE OR DELETE ON mt_moto
FOR EACH ROW
DECLARE
  v_usuario VARCHAR2(50);
  v_old CLOB;
  v_new CLOB;
BEGIN
  v_usuario := NVL(USER, 'SISTEMA');

  IF INSERTING THEN
    v_new := '{"idmoto":' || :NEW.idmoto || ',"placa":"' || :NEW.placamoto || '"}';
    pkg_auditoria.grava_auditoria('MT_MOTO', v_usuario, 'INSERT', NULL, v_new);
  ELSIF UPDATING THEN
    v_old := '{"idmoto":' || :OLD.idmoto || ',"placa":"' || :OLD.placamoto || '"}';
    v_new := '{"idmoto":' || :NEW.idmoto || ',"placa":"' || :NEW.placamoto || '"}';
    pkg_auditoria.grava_auditoria('MT_MOTO', v_usuario, 'UPDATE', v_old, v_new);
  ELSIF DELETING THEN
    v_old := '{"idmoto":' || :OLD.idmoto || ',"placa":"' || :OLD.placamoto || '"}';
    pkg_auditoria.grava_auditoria('MT_MOTO', v_usuario, 'DELETE', v_old, NULL);
  END IF;
END;
/